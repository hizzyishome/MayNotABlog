---
title: 口水Java虚拟机
comments: true
date: 2018-08-25 12:14:45
updated: 2018-08-25 12:14:45
tags:
    - Java
    - jvm
    - 笔记
categories: 码文
---

## Java运行方式
- 在JRE下(JRE 仅包含运行 Java 程序的必需组件，包括 Java 虚拟机以及 Java 核心类库等。JDK包含JRE，附带开发、诊断工具。)
- C++无需额外的运行环境。直接编译成 CPU 所能理解的机器码。

## 为什么 Java 要在虚拟机里运行？
- Java语法复杂，抽象程度高。直接在硬件上运行不现实。所以呢，在运行 Java 前转换。
- 设计一个虚拟机，通过编译器将Java转换成该虚拟机所能识别的指令序列，也称 Java 字节码。因为 Java 字节码指令的操作码（opcode）被固定为一个字节。
- 不同的是，比起C++，Java的编译结果相对精简一些。因为Java虚拟机相对于物理机而言，抽象程度更高。
- Java 虚拟机可以由硬件实现
- 各个现有平台（如 Windows_x64、Linux_aarch64）上软件实现。这么做的意义在于，一旦一个程序被转换成 Java 字节码，
可以在不同平台上的虚拟机实现里运行。这也就是我们经常说的“一次编写，到处运行”。
- 虚拟机的另外一个好处是托管环境（Managed Runtime）。这个托管环境能够代替我们处理一些代码中冗长而且容易出错的部分。
其中最广为人知的 自动内存管理 垃圾回收.除此之外，数组越界、动态类型、安全权限等动态检测，使免于书写无关业务逻辑代码。

## Java 虚拟机具体是怎样运行 Java 字节码的？
1. 虚拟机视角，首先java文件编译的class文件加载到Java虚拟机中
2. 加载后的Java类会被存放于方法区（Method Area）中
3. 实际运行时，虚拟机会执行方法区内的代码。
4. 运行过程调用进入一个Java方法，Java虚拟机在当前线程的Java方法栈中生成一个栈帧，存放局部变量以及字节码的操作数。
这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。
5. 当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。

- 和X86的段式内存管理类似，Java虚拟机也在内存中划分出堆和栈来存储运行时数据。
- 不同的是，Java虚拟机将栈细分为面向Java方法的Java方法栈，面向本地方法（用 C++ 写的 native 方法）的本地方法栈，
以及存放各个线程执行位置的PC寄存器。

![1](./1.png)  

- 从硬件视角来看，Java 字节码无法直接执行。因此，Java 虚拟机需要将字节码翻译成机器码。

1. HotSpot里第一种是解释执行，逐条将字节码翻译成机器码并执行. ***无需等待编译***
2. 第二种是即时编译（Just-In-Time compilation，JIT），
将一个方法中包含的所有字节码编译成机器码后再执行。 ***实际运行速度更快***

- HotSpot 默认采用混合模式，综合了解释执行和即时编译两者的优点。
先解释执行字节码，而后将其中反复执行的热点代码，以方法为单位进行即时编译。

## Java 虚拟机的运行效率究竟是怎么样的？

- 即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。
- 对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；
另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。
- 为了满足不同用户场景的需要，HotSpot 内置了多个即时编译器：C1、C2 和 Graal。
- C1 又叫做 Client 编译器，面向的是对启动性能有要求的客户端 GUI 程序，采用的优化手段相对简单，因此编译时间较短。
- C2 又叫做 Server 编译器，面向的是对峰值性能有要求的服务器端程序，采用的优化手段相对复杂，因此编译时间较长，但同时生成代码的执行效率较高。
- Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。
- 为了不干扰应用的正常运行，HotSpot 的即时编译是放在额外的编译线程中进行的,根据 CPU 的数量设置编译线程的数目，
并且按 1:2 的比例配置给 C1 及 C2 编译器。
- 在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行。
![2](./2.png)

## Java 虚拟机的 boolean 类型
- 在 Java 语言规范中，boolean 类型的值只有符号“true”和“false”。显然，这两个符号是不能被虚拟机直接使用的。
- 在 Java 虚拟机规范中，boolean 类型则被映射成 int 类型。具体来说，“true”被映射为整数 1，而“false”被映射为整数 0。
这个编码规则约束了 Java 字节码的具体实现。

## Java 的基本类型
![3](./3.png)
- byte、short、int、long、float 以及 double 的值域依次扩大，而且前面的值域被后面的值域所包含。
从前面的基本类型转换至后面的基本类型，无需强制转换。尽管他们的默认值看起来不一样，但在内存中都是 0。
- 在这些基本类型中，boolean 和 char 是唯二的无符号类型。在不考虑违反规范的情况下，boolean 类型的取值范围是 0 或者 1。
char 类型的取值范围则是 [0, 65535]。通常我们可以认定 char 类型的值为非负数。这种特性十分有用，比如说作为数组索引等。

## Java对象的内存布局
0. HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
0. 对象头（Header）包括两部分信息:
    - "Mark Word",标记字段,标记信息:存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳
    - 类型指针:确定这个对象是哪个类的实例,不是所有的虚拟机实现都必须在对象数据上保留类型指针.，如果对象是一个Java数组，
    那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，
    但是从数组的元数据中却无法确定数组的大小。
0. 实例数据（Instance Data）:对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，
还是在子类中定义的，都需要记录起来。
0. 对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍
,换句话说，就是对象的大小必须是8字节的整数倍。
1. 通过 new 指令新建出来的对象，由于都隐式或者显式的调用了父类,直到Object的构造方法,所以其实它的内存其实涵盖了所有父类中的实例字段。
也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存的。
2. 压缩指针
    1. 概述
        - Java 虚拟机中，每个 Java 对象都有一个对象头（object header）,由标记字段和类型指针所构成.
        - 标记字段:64位,8字节.用以存储 Java 虚拟机有关该对象的运行数据:哈希码、GC 信息以及锁信息
        - 类型指针:64位,8字节.指向该对象的类
        - 在 64 位的 Java 虚拟机中，对象头的标记字段占 64 位，而类型指针又占了 64 位。每一个 Java 对象在内存中的**额外开销**就是 16 个字节。
        - 64 位 Java 虚拟机引入了压缩指针的概念-XX:+UseCompressedOops，默认开启.将堆中原本 64 位的 Java 对象指针压缩成 32 位的。
        - 类型指针64 --> 32, 减少了32字节,4字节.所以对象头从16字节,减少为12字节.
        - 压缩指针作用于*对象头的类型指针*，*引用类型的字段*，以及*引用类型数组*。
    2. 原理
        - 32位的压缩指针,可以标记2的32次方个对象,如果一个对象占据2位,对应内存空间需要2的33次方.
        - 但是对象大小各有不同,不可能都是一样大小,所以需要定长的扩展单位.***内存对齐***.对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8
        - 默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数
3. 内存对齐
    - 对应虚拟机选项 -XX:ObjectAlignmentInBytes，默认值为 8
    - 默认情况下，Java 虚拟机堆中对象的起始地址需要对齐至 8 的倍数
    - 如果一个对象用不到 8N 个字节，那么空白的那部分空间就浪费掉了。这些浪费掉的空间我们称之为**对象间的填充（padding）**。
    - 所以在默认情况下，Java 虚拟机中的 32 位压缩可以寻址到 2 的 35 次方个字节(2^32*2^3)，也就是 32GB 的地址空间（超过 32GB 则会关闭压缩指针）。
    - 对压缩指针解引用时，我们需要将其左移 3 位(就是乘以8恢复真实地址)，再加上一个固定偏移量，便可以得到能够寻址 32GB 地址空间的
    伪 64 位指针了。
    - 我们可以通过配置刚刚提到的内存对齐选项（-XX:ObjectAlignmentInBytes）来进一步提升寻址范围。比如16.寻址到2^36地址空间
    - 但是可能增加对象间填充，导致压缩指针没有达到原本节省空间的效果。
    - **内存对齐不仅存在于对象与对象之间，也存在于对象中的字段之间。**:Java 虚拟机要求 long 字段、double 字段，
    以及非压缩指针状态下的引用字段地址为 8 的倍数。
    - 字段内存对齐的其中一个原因，是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。
    也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。
    这两种情况对程序的执行效率而言都是不利的。为了处理这种情况,采用**字段重排列**
4. 字段重排列
    - Java 虚拟机重新分配字段的先后顺序,以达到内存对齐的目的。有三种排列方法,对应 Java 虚拟机选项 -XX:FieldsAllocationStyle，默认值为 1
    - Java 虚拟机字段重排列遵循的两个规则
        1. 如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。
        以 long 类为例，它仅有一个 long 类型的实例字段。在使用了压缩指针的 64 位虚拟机中，尽管对象头的大小为 12 个字节，
        该 long 类型字段的偏移量也只能是 16，而中间空着的 4 个字节便会被浪费掉。
        2. 子类所继承字段的偏移量，需要与父类对应字段的偏移量保持一致。Java 虚拟机还会对齐子类字段的起始位置。
        对于使用了压缩指针的 64 位虚拟机，子类第一个字段需要对齐至 4N；而对于关闭了压缩指针的 64 位虚拟机，子类第一个字段则需要对齐至 8N。
        3. 
    - @Contended解决对象字段之间的虚共享（false sharing）问题.这个注释也会影响到字段的排列。
    - 虚共享:假设两个线程分别访问同一对象中不同的 volatile 字段，逻辑上它们并没有共享内容，因此不需要同步。
    然而，如果这两个字段恰好在同一个缓存行中，那么对这些字段的写操作会导致缓存行的写回，也就造成了实质上的共享。
    - Java 虚拟机会让不同的 @Contended 字段处于独立的缓存行中，因此你会看到大量的空间被浪费掉。
    - JOL 工具 打印工程中的类的字段分布情况