---
title: java base point and think
comments: true
date: 2019-03-14 15:50:00
updated: 2019-03-14 15:50:00
tags:
categories:
---
#### 有时候走了太久太远，都忘了为什么出发了。

1. 面向过程和面向对象
    1. 面向过程
        1. 概：面向对象在我印象里是最初在C中获得的，注重顺序思维，结构化编程，即使封装
        函数也是为了复用，而不是降低耦合。
        2. 优点：比面向对象性能更好，不用实例化，节省资源。性能因素占绝对重要性时，
        优考虑面向过程的开发。
        3. 缺点：流式思维，不符合客观世界规律，比起面向对象，更难维护、复用和、扩展。
    2. 面向对象：
        1. 概：是现实世界关系的抽象，符合现实世界的逻辑规律。
        2. 优点：抑郁维护复用和扩展。有封装、继承和多态的特性。
        3. 缺点：资源开销大，性能比面向过程差。
    3. 言之： 现在除了特别对性能有要求的一些项目，对于更多的业务系统讲，机器资源一般是
    较为满足的，更注重的是易维护，易扩展，业务系统大概占据了软件开发项目八成，所以在业务系统上，
    采用面向对象的方式进行开发。（现在的互联网行业人员流动那么大，程序员的编程水平习惯参差不齐，
    如果还不注重维护性和扩展性的话，那大概就是前人挖坑闪后人，后人再挖，闪后后人，
    子子孙孙无穷匮也。）
2. Java的特点
    1. 优点：
        1. 学习成本底。（相比C和C++吧，比Python还差些 :smile:）
        2. 面向对象。（C++也是面向对象的，严格的说面向对象是一种思想）
        3. 平台无关。可移植性好。（只要这个平台有对应的jvm，你只管敲你的Java代码，
        编译成class后，jvm去生产适配各个平台的机器指令。）
        4. 可靠性。（因为强类型？怎么就比其他语言更可靠了？质疑）
        5. 安全性。（和强类型有关，也没有C里指针的各种乱指）
        6. 多线程支持。（C++没有内置的对多线程的支持，需要调用系统的多线程支持）
        7. 方便的网络编程。（简化了网络编程是指对JavaWeb方向的扩展么？确实在C里网络编程中的
        通信一些东西确实比较复杂。）
        8. 编译与解释并存。（Java确实从解释语言里学了很多，这点是我很欣赏的，知道发展自身，
        才是生存下去的道理。）
    2. 缺点：
        1. 初期性能经常与C系比较，确实差一些，但是现在的java性能已经不能被诟病了。
        2.

3. JVM JDK JRE
    1. JVM（Java Virtual Machine）
        - 运行java字节码，字节码class文件jvm能理解
        - 对不同系统有不同实现
        - class文件只面向jvm，各个平台上都是一样的
        - 一方面解决了解释型语言效率低问题
        - 保留了解释性语言可移植性
        - 在不同平台上不需要重新编译，可以直接运行
        - .java文件  -- jdk中的javac --> .class文件
        - .class文件  -- jvm --> 二进制机器码。jvm类加载器首先加载字节码文件，
        解释器逐行解释执行。但是热点代码会多次被解释，所以引进了JIM(Just In Time)编译器。
        运行时编译器，完成一次编译以后，字节码对应的机器码保存，下次调用到直接使用。
        这一部分属于编译后调用，每次重新编译的是解释的部分。
        - HotSpot 惰性评估(Lazy Evaluation)  热点代码是需要JIT编译的部分
        JVM根据每次执行的情况收集信息并且相应的优化 执行次数越多，速度越快
        JDK9引入AOT(Ahead of Time Compilation)编译，直接将字节码编译成机器码，
        避免了JIT模式下的预热开销。
        - 支持分层编译和AOT协作使用 ``？？？``   AOT编译质量不如JIT``？？？``
        - 字节码 和 不同系统的JVM实现 保证了一次编译到处运行
    2. JDK
        - Java Development Kit
        - 包括JRE
        - 编译器
        - 其他工具
    3. JRE
        - Java Runtime Environment
        - 运行已编译java程序
        - 包括jvm java类库 java命令 其他基础构件
        - 包含jsp的web程序，也需要jdk，因为需要将JSP转换为Java servlet，需要jsk编译servlet。
4. Oracle JDK 和 OpenJDK
    1. Oracle JDK
        - 不是完全开源的
        - 更稳定，优化更多，效率可能更高？
    2. OpenJDK
        - 开源
        - GPL许可协议

5. Java和C++的区别
    1. 共通：面向对象，支持继承封装和多态
    2. java: 不提供指针访问内存，更安全   类单继承   接口多继承  内存管理机制
    3. C++： 提供指针   类可以多继承   需要程序员释放内存

6. 字符型常量和字符串常量的区别
    1. ``` char c = 'c';  String s = "sss";```
    2. 字符相当于ascII值，可以参加运算。字符串代表地址，即在内存中存放位置。
    3. char类型占2个字节 2*8bit = 16bit；字符串至少一个，结束标志（这句并不对，
    在C++中，以\0作为结束，但是在Java中，String是对象，有长度属性，不需要表示结尾）

7. 构造器 Constructor 是否可被 override
    - 父类的私有属性和构造方法并不能被继承
    - Constructor 也就不能被 override（重写）
    - 可以overload（重载）

8. Java 面向对象编程三大特性: 封装 继承 多态
    1. 封装把对象属性私有化，提供可以被外界访问的属性的方法，
    可不提供，但是如果一个类没有提供给外界访问的方法，那这个类也没有什么意义了。
    2. 继承是使用已存在的类的定义作为基础建立新类的技术，
    新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。
    通过使用继承能复用以前的代码。
    3. - 子类有父类非private属性和方法
        - 子类可以有自己的属性和方法
        - 子类可以重写父类非private方法（构造方法呢？基于自己的+super()）
    4. 多态指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用，
    在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，
    该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。
        - 继承实现（多个子类对同一方法的重写）
        - 接口实现（实现接口并覆盖接口中同一方法）。

9. String StringBuffer 和 StringBuilder
    1. 可变性
        - String -> private final char value[];  不可变
        - StringBuilder 与 StringBuffer 都继承AbstractStringBuilder    char[] value; 可变
    2. 线程安全性
        - String final 常量线程安全
        - StringBuilder 没有对方法加同步锁，非线程安全
        - StringBuffer  加了同步锁，线程安全
    3. 性能
        - 对String变量改变赋值，生成新String对象，指针指向新的String对象
        - StringBuffer每次操作自己
        - StringBuilder 有更高的性能
    4. 少量数据为了方便直接String   操作大量数据 单线程StringBuilder  多线程StringBuffer

10. 在一个静态方法内调用一个非静态成员为什么是非法的
    - 静态方法不通过对象去调用方法

11. 在 Java 中定义一个不做事且没有参数的构造方法的作用
    - 继承 子类中的super() 调用父类中无参数构造函数 如果出现这种情况，而父类中没有，报错

12.  import java和javax有什么区别
    - 刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。
    - 然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。
    - 但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。
    - 因此，最终决定 javax 包将成为标准API的一部分。
    - 所以，实际上java和javax没有区别。这都是一个名字。

13. 接口和抽象类的区别是什么
    1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法实现
    2. 接口中的实例变量默认是 final 类型的，而抽象类中则不一定
    3. 一个类可以实现多个接口，但最多只能实现一个抽象类(java中接口和继承的区别)
    4. 一个类实现接口的话要实现接口的所有方法，而抽象类不一定(不实现默认使用父类)
    5. 接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象
    从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

14. 成员变量与局部变量的区别有那些
    1. 从语法形式上
        - 看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数
        - 成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；
        - 成员变量和局部变量都能被 final 所修饰；
    2. 从变量在内存中的存储方式来看
        - 如果成员变量是使用static修饰的，那么这个成员变量是属于类的
        - 如果没有使用使用static修饰，这个成员变量是属于实例的。
        - 而对象存在于堆内存，局部变量存在于栈内存
    3. 从变量在内存中的生存时间上看
        - 成员变量是对象的一部分，它随着对象的创建而存在
        - 局部变量随着方法的调用而自动消失。
    4. 成员变量如果没有被赋初值
        - 则会自动以类型的默认值而赋值(一种情况例外被 final 修饰的成员变量也必须显示地赋值)
        - 局部变量则不会自动赋值。

15. 创建一个对象用什么运算符?对象实体与对象引用有何不同?
    - new运算符，new创建对象实例（对象实例在堆内存中）
    - 对象引用指向对象实例（对象引用存放在栈内存中）
    - 一个对象引用可以指向0个或1个对象（一根绳子可以不系气球null，也可以系一个气球）
    - 一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）获取同一个对象

16. 构造方法特性
    - 名字与类名相同
    - 没有返回值，但不能用void声明
    - 生成类的对象自动执行，无需调用

17. 静态方法和实例方法有何不同
    - 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式，
    调用静态方法可以无需创建对象。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），
    而不允许访问实例成员变量和实例方法.
    - 实例方法只有"对象名.方法名"的方式，实例方法可以访问所有成员和方法

18. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是帮助子类做初始化工作。

19. == 与 equals
    1. ==
        - 它的作用是判断两个对象的地址是不是相等，两个对象是不是同一个对象。
        - 基本数据类型==比较的是值，引用数据类型==比较的是内存地址
    2. equals()
        - 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。
        - 类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；
        若它们的内容相等，则返回 true (即，认为这两个对象相等)。
        - String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，
        而 String 的 equals 方法比较的是对象的值。
        - 创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，
        如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。
20. hashCode 与 equals
    1. hashCode
        - hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。
        - 这个哈希码的作用是确定该对象在哈希表中的索引位置。
        - hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。
        - 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。
        这其中就利用到了散列码！（可以快速找到所需要的对象）
    2. 为什么要有 hashCode
        - 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，
        同时也会与其他已经加入的对象的 hashcode 值作比较
        - 如果没有相符的hashcode，HashSet会假设对象没有重复出现。
        - 但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。
        - 如果两者相同，HashSet 就不会让其加入操作成功。
        - 如果不同的话，就会重新散列到其他位置。
        - 大大减少了 equals 的次数，相应就大大提高了执行速度。
    3. hashCode（）与equals（）的相关规定
        - 如果两个对象相等，则hashcode一定也是相同的
        - 两个对象相等,对两个对象分别调用equals方法都返回true
        - 两个对象有相同的hashcode值，它们也不一定是相等的
        - 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖
        - hashCode() 的默认行为是对堆上的对象产生独特值。
        如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

21. 为什么Java中只有值传递
    - 基本类型值，将值拷贝，进行值传递。对象传递的话，将对象的引用（地址）拷贝，进行值传递。
    但是地址的copy值指向同一个对象，方法对对象成员的改动，即改动了对象在内存里的值，会反映在外部。
    然而，如果直接换引用，是换了copy的引用，和外部原来的引用并没有关系。