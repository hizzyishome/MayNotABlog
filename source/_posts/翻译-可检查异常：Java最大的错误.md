---
title: '[翻译]可检查异常：Java最大的错误'
date: 2019-09-26 00:02:02
updated: 2018-09-28 00:27:32
comments: true
tags: 
    - java
    - 翻译
    - 异常
categories: java
---
{% blockquote %}
原文链接：http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/
{% endblockquote %}

可检查异常一直以来都是java语言中备受争议一个特性。

拥趸者宣称可检查异常能保证程序能在在运行中检查出异常，并且从程序异常中恢复。
反对者却说即便“catch”代码块存在，但程序几乎不可能从异常中恢复，而且成为一个经常出错的点。
更加之Java 8之后，新增了lambdas表达式的特性，是不是可检查异常在java世界中正变成一个鸡肋的特性？

### java设置可检查异常特性的初衷

90年代中期，James Gosling在Sun公司提出了一种新的语言。当时，在c++编程中要求每个函数的返回都要检查错误。他认为必须有一个更好的解决方案，
就在这种新的Java语言中创建了异常的概念。

可检查异常的本来目的是为了做本地标记并强制开发者去处理的可能发生的异常。可检查异常必须在方法声明时标注（方法后throw），否则必须在代码里去处理（try-catch）。
设计这种模式的目的是为了增强软件的可靠性和恢复性。期望从除了成功之外的其他可预见意外结果中“恢复”程序的运行，比如在尝试付款时抛出资金不足（InsufficientFundsException）
的可检查异常。至于需要做哪些操作让程序“恢复”，就很难去搞清楚了。（因为你付款失败，所以我catch里给你账户上补钱，让你付款成果？虽然你长得丑，但是你想得美。）

运行时异常也包括在java中。因为空指针异常NPE，数据错误或者非法状态、非法访问这些错误可能在代码运行过程中的某些地方产生，所以他们都是运行时异常的子类。

运行时异常不需要声明就可以在任何地方抛出，比起可检查异常更方便。但是运行时异常可以代替可检查异常吗？

### 弊端
这里的关键点在于，运行时异常和可检查异常在功能上是等价的。区别在于运行时异常不能处理或者从异常中恢复而可检查异常可以。

对可检查异常最大的争议点在于，大多数异常都无法恢复的。简单来说，我们并没有发生异常的子系统代码。我们看不到子系统的具体实现，所以我们并不能对它负责，
更无法修复它。

在JDBC (SQLException)和EJB中的RMI (RemoteException)中体现的最为突出。与按照最初可检查异常设计的明确可修复的意外情况不同，
这些强制的普遍的系统可靠性问题事实上时并不能被修复的异常，被到处声明。（java代码里一堆没有的catch，有些问题catch下来你也没辙，但是不catch编译都不能通过）

对于任何一个方法来说，它可能出现的异常包括它调用的所有子方法可能发生的异常。在一个方法上声明这么多可能存在的异常，
让开发者去看这些通过调用树传上来的异常，已经不能提供一个明确的本方法相关的重点给开发者了。

大多数EJB开发人员都经历过这种声明的异常，在方法相关的每一层或者整个代码库中都必须声明。（尤其底层）调用一个抛出不同异常的方法，需要修改大量于其相关的方法。

许多开发人员被告知尽量捕获低级异常，并将它们作为高级(应用级)可检查异常重新抛出。这样做需要每个项目多出2000个以上没有任何功能性的catch-throw”代码块。

这样就导致生吞异常、隐藏异常原因、重复打印日志和返回未初始化数据或者返回空指针变得很普遍。大多数项目可能会出现600+的上述编码错误或完全错误的用法。

最终，开发者反对代码中出现大量的已经变成许多错误源头的catch代码块。

### 可检查异常与函数式编程不兼容
