---
title: '[翻译]可检查异常：Java最大的错误'
date: 2019-09-26 00:02:02
updated: 2019-09-28 00:27:32
comments: true
tags: 
    - java
    - 翻译
    - 异常
categories: java
---
{% blockquote %}
原文链接：http://literatejava.com/exceptions/checked-exceptions-javas-biggest-mistake/
{% endblockquote %}

可检查异常一直以来都是java语言中备受争议一个特性。

拥趸者宣称可检查异常能保证程序能在在运行中检查出异常，并且从程序异常中恢复。
反对者却说即便“catch”代码块存在，但程序几乎不可能从异常中恢复，而且成为一个经常出错的点。
更加之Java 8之后，新增了lambdas表达式的特性，是不是可检查异常在java世界中正变成一个鸡肋的特性？

### java设置可检查异常特性的初衷

90年代中期，James Gosling在Sun公司提出了一种新的语言。当时，在c++编程中要求每个函数的返回都要检查错误。他认为必须有一个更好的解决方案，
就在这种新的Java语言中创建了异常的概念。

可检查异常的本来目的是为了做本地标记并强制开发者去处理的可能发生的异常。可检查异常必须在方法声明时标注（方法后throw），否则必须在代码里去处理（try-catch）。
设计这种模式的目的是为了增强软件的可靠性和恢复性。期望从除了成功之外的其他可预见意外结果中“恢复”程序的运行，比如在尝试付款时抛出资金不足（InsufficientFundsException）
的可检查异常。至于需要做哪些操作让程序“恢复”，就很难去搞清楚了。（因为你付款失败，所以我catch里给你账户上补钱，让你付款成果？虽然你长得丑，但是你想得美。）

运行时异常也包括在java中。因为空指针异常NPE，数据错误或者非法状态、非法访问这些错误可能在代码运行过程中的某些地方产生，所以他们都是运行时异常的子类。

运行时异常不需要声明就可以在任何地方抛出，比起可检查异常更方便。但是运行时异常可以代替可检查异常吗？

### 弊端
这里的关键点在于，运行时异常和可检查异常在功能上是等价的。区别在于运行时异常不能处理或者从异常中恢复而可检查异常可以。

对可检查异常最大的争议点在于，大多数异常都无法恢复的。简单来说，我们并没有发生异常的子系统代码。我们看不到子系统的具体实现，所以我们并不能对它负责，
更无法修复它。

在JDBC (SQLException)和EJB中的RMI (RemoteException)中体现的最为突出。与按照最初可检查异常设计的明确可修复的意外情况不同，
这些强制的普遍的系统可靠性问题事实上时并不能被修复的异常，被到处声明。（java代码里一堆没有的catch，有些问题catch下来你也没辙，但是不catch编译都不能通过）

对于任何一个方法来说，它可能出现的异常包括它调用的所有子方法可能发生的异常。在一个方法上声明这么多可能存在的异常，
让开发者去看这些通过调用树传上来的异常，已经不能提供一个明确的本方法相关的重点给开发者了。

大多数EJB开发人员都经历过这种声明的异常，在方法相关的每一层或者整个代码库中都必须声明。（尤其底层）调用一个抛出不同异常的方法，需要修改大量于其相关的方法。

许多开发人员被告知尽量捕获低级异常，并将它们作为高级(应用级)可检查异常重新抛出。这样做需要每个项目多出2000个以上没有任何功能性的catch-throw”代码块。

这样就导致生吞异常、隐藏异常原因、重复打印日志和返回未初始化数据或者返回空指针变得很普遍。大多数项目可能会出现600+的上述编码错误或完全错误的用法。

最终，开发者反对代码中出现大量的已经变成许多错误源头的catch代码块。

###  可检查异常 - 与函数式编程不兼容

然后我们迎来了Java 8，它提供了新的函数式编程特性，比如lambdas表达式、Streams流和组合函数。

这些特性建立在泛型的基础上，参数和返回类型被泛型化，因此迭代操作和流操作(forEach、map、flatMap)可以通过共同的操作实现，而不用管对象类型时什么。

但是，与数据类型不同，声明的异常不能泛型化。

在Java中不能提供一个用lambda声明某个可检查的异常流操作(例如stream .map)，并显式的将该可检查异常传递给上下文代码。

对可检查异常来所最重要的一点在于，所有介于一个throw和接收catch中间的代码块被强制要求声明异常。

这个问题通过将可检查异常“包装”在RuntimeException运行时异常中解决，隐藏了异常的原始类型，通过对具体的异常“catch”代码块渲染包装来应对原生的异常概念，
使之失效。

Finally we can capture Java’s new philosophy in a nutshell, by noting that none of the new “functional interfaces” 
in Java 8 declare checked exceptions.
最后，通过注意到Java 8中没有一个新的函数式接口（“functional interfaces”）声明可检查异常这个特点，我们可以简单的抓住Java新哲学的核心
（新核心是什么？简洁简洁简洁！java设计者终于意识到这个问题了。避免可检查异常引出的大段catch无用代码。）ji'shi

### 结论

与早期语言相比，Java中的异常机制主要带来了可靠性和严谨的错误处理方面的优势。Java保证了提供可靠的服务和商业软件，但c++永远不可能做到这一点。

可检查异常最初的设计意图是处理意外事件而不是程序错误。值得称道的目的是重点突出了明确可预测的错误点(无法连接、找不到文件等)，并确保开发人员必须处理这些问题。

但强制声明大量的系统错误和不可恢复的故障却从未包含的在最初的设计概念里。这些被声明为可检查异常的错误是不可能被修正的。

通常在代码中和EJB应用或者web应用、Swing、AWT容器应用中可能出现故障，已经通过提供一个最外层的请求失败（“failed request”）异常处理机制来解决这个异常。应该采取最基本的正确策略是回滚事务并返回错误信息。

***运行时异常接受任何可检查异常可能存在的异常处理操作，但要避免限制性编码约束。*** 这种机制简化了编码，异常在最外层或者尽可能高的层级去处理的这使得编码工作更容易遵循早期抛出、晚期捕获的最佳实践。

一些领先的Java框架和有影响力的代码实践，现在已经明确地移除了可检查异常机制的使用。Spring、Hibernate和现代Java框架开发商只使用运行时异常，运行时异常的便利性是它大受欢迎的主要因素。

知名java大牛Josh Bloch (Java Collections framework研发者)、Rod Johnson、Anders Hejlsberg (c#之父)、Gavin King和Stephen Colebourn (JodaTime研发者)都可检查异常的使用。

现在，在Java 8中，lambdas是向前迈出的基本一步。这些语言特性使得控制流从内部的函数式操作中抽象出来。正如我们已经看到的，这些新特性使得可检查异常，包括它的声明和异常处理机制的立刻显得过时了。

对于开发人员来说，注意代码的可靠性和预先诊断代码可能的出现故障的点(或意外时间事件)是很重要的，例如打开文件、连接数据库等操作。如果我们能在这方面提供一个良好实现的错误信息，我们可能达到软件工程师成就的顶峰——开发有自我诊断能力的软件。

但是，我们应该使用不可检查异常（RuntimeException）来实现这种目的。如果这个异常必须重新抛出，应该坚持使用RuntimeException或者应用特定的异常子类。

正如Stephen Colebourn所说，如果你的项目仍然在使用或提倡可检查异常，那么你的java技能已经过时5-10年了。Java已经有了长足的进步。









































